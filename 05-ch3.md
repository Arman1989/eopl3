# Expressions

## Key Points

We always need a front end that converts programs into abstract syntax trees.

It's all basically interpreters.

...

## Notes

In this chapter, we study the binding and scoping of variables.

### 3.1 Specification and Implementation Strategy

The specification will consist of assertions of the form

```
(value-of exp ρ) = val
```

meaning that the value of expression `exp` in environment `ρ` is `val`.

**Execution via interpreter**

*program text -> [Front End] -> syntax tree -> [Interpreter] -> answer*

**Execution via compiler**

*program text -> [Front End] -> syntax tree -> [Compiler] -> translated program -> [Interpreter or Machine] -> answer*

The **source language** or **the defined language** is the text of the program
written in the language we are implementing.

The **implementation language** or **the defining language** is the language in
which the interpreter is written.

In the compiler organization the **target language** is often machine language,
which is interpreted by a hardware machine. Another possibility is that the
target language is a special-purpose language called a **byte-code**, and its
interpreter is called a **virtual machine**.

A compiler is typically divided into 2 parts:

1. An **analyzer**. It attempts to deduce useful information about the program.
2. A **translator**. It does the translation, possibly using information from
the analyzer.

No matter what implementation strategy we use, we need a front end that converts
programs into abstract syntax trees.

The front end can be grouped into 2 stages:

1. **Scanning**. It is the process of dividing the sequence of characters into
words, numbers, punctuation, comments and the like. These units are called
**lexical items**, **lexemes** or **tokens**. The **lexical specification**
specifies the way in which a program should be divided up into tokens.

2. **Parsing**. It is the process of organizing the sequence of tokens into
hierarchical syntactic structures such as expressions, statements and blocks.
We refer to this as the **syntactic** or **grammatical** structure of the
language. The parser takes a sequence of tokens from the scanner and produces
an abstract syntax tree.

The standard approach to building a front end is to use a **parser generator**.
A parser generator is a program that takes a lexical specification and a
grammar, and produces a scanner and a parser for them.

### 3.2 LET: A Simple Language

An important part of the specification of any programming language is the set
of values that the language manipulates. Each language has at least two such
sets: the **expressed values** and the **denoted values**.

The expressed values are the possible values of expressions.

The denoted values are the values bound to variables.

If we are going to evaluate expressions containing variables, we will need to
know the value associated with each variable. We do this by keeping those
values in an environment.

An environment is a function whose domain is a finite set of variables and
whose range is the denoted values.

```
env : Identifier -> DenVal
```

**Syntax for the LET language**

```
Program    ::= Expression
               [(a-program exp)]

Expression ::= Number
               [(const-exp n)]

           ::= -(Expression, Expression)
               [(diff-exp exp1 exp2)]

           ::= zero? (Expression)
               [(zero?-exp exp)]

           ::= if Expression then Expression else Expression
               [(if-exp exp1 exp2 exp3)]

           ::= Identifier
               [(var-exp v)]

           ::= let Identifier = Expression in Expression
               [(let-exp v exp body)]
```

**Semantics for the LET language**

```
ExpVal = Int + Bool
DenVal = Int + Bool


(value-of-program (a-program exp))
= (value-of exp ρ) ; for some initial environment ρ


(value-of (const-exp n) ρ)
= (num-val n)


(value-of (var-exp v) ρ)
= (apply-env ρ v) ; since DenVal = ExpVal this works


(value-of (diff-exp exp1 exp2) ρ)
= (num-val
    (- (expval->num (value-of exp1 ρ))
       (expval->num (value-of exp2 ρ))))


   (value-of exp ρ) = val
----------------------------
(value-of (zero?-exp exp) ρ)
= (bool-val #t) if (expval->num val) == 0
= (bool-val #f) if (expval->num val) /= 0


     (value-of exp1 ρ) = val1
------------------------------------
(value-of (if-exp exp1 exp2 exp3) ρ)
= (value-of exp2 ρ) if (expval->bool val1) == #t
= (value-of exp3 ρ) if (expval->bool val1) == #f


     (value-of exp ρ) = val
---------------------------------
(value-of (let-exp v exp body) ρ)
= (value-of body [v=val]ρ)
```

### 3.3 PROC: A Language with Procedures
### 3.4 LETREC: A Language with Recursive Procedures
### 3.5 Scoping and Binding of Variables
### 3.6 Eliminating Variable Names
### 3.7 Implementing Lexical Addressing
